name: Create Regional Test VM

on:
  workflow_dispatch:
    inputs:
      region:
        type: string
        description: 'GCP Region (e.g., us-central1, europe-west1, asia-south1)'
        required: true
      zone:
        type: string  
        description: 'GCP Zone (e.g., us-central1-a, europe-west1-b)'
        required: true
      machine_type:
        type: choice
        description: 'VM Machine Type'
        options:
          - 'e2-micro'
          - 'e2-small' 
          - 'e2-medium'
          - 'e2-standard-2'
          - 'e2-standard-4'
          - 'n1-standard-1'
          - 'n1-standard-2'
        default: 'e2-medium'
      disk_size:
        type: choice
        description: 'Boot Disk Size (GB)'
        options:
          - '20'
          - '30'
          - '50'
          - '100'
        default: '30'
      vm_name_suffix:
        type: string
        description: 'VM Name Suffix (optional)'
        required: false
        default: ''
      auto_cleanup_hours:
        type: choice
        description: 'Auto-cleanup VM after (hours)'
        options:
          - '2'
          - '4'
          - '8'
          - '12'
          - '24'
          - '48'
          - '72'
        default: '8'

jobs:
  create-vm:
    runs-on: ubuntu-latest
    environment: main
    
    permissions:
      contents: read
      id-token: write
    
    env:
      PROJECT_ID: "vsa-ai-prod"
      REGION: ${{ github.event.inputs.region }}
      ZONE: ${{ github.event.inputs.zone }}
      DEPLOYMENT_ID: ${{ github.run_id }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_VSA_PROD }}
      
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
      
      - name: Generate VM Name
        id: vm-name
        run: |
          SUFFIX="${{ github.event.inputs.vm_name_suffix }}"
          if [[ -z "$SUFFIX" ]]; then
            SUFFIX="$(date +%m%d%H%M)"
          fi
          VM_NAME="test-vm-${{ env.REGION }}-${SUFFIX}-${{ env.DEPLOYMENT_ID }}"
          echo "vm_name=$VM_NAME" >> $GITHUB_OUTPUT
      
      - name: Create Firewall Rule
        run: |
          FIREWALL_RULE="allow-test-services-${{ env.DEPLOYMENT_ID }}"
          gcloud compute firewall-rules create "$FIREWALL_RULE" \
            --allow tcp:5000,tcp:8080,tcp:22,tcp:9999 \
            --source-ranges 0.0.0.0/0 \
            --description "Test services for deployment ${{ env.DEPLOYMENT_ID }}" \
            --target-tags "test-vm-${{ env.DEPLOYMENT_ID }}"
      
      - name: Generate Startup Script
        run: |
          cat > startup-script.sh << 'EOF'
          #!/bin/bash
          exec > /var/log/startup.log 2>&1
          
          # Update and install packages
          apt-get update -y
          apt-get install -y curl wget git jq bc docker.io docker-compose python3 python3-pip
          
          # Start Docker
          systemctl start docker
          systemctl enable docker
          usermod -aG docker debian
          
          # Install Go
          wget -q https://go.dev/dl/go1.21.5.linux-amd64.tar.gz -O /tmp/go.tar.gz
          tar -C /usr/local -xzf /tmp/go.tar.gz
          echo 'export PATH=$PATH:/usr/local/go/bin' >> /etc/profile
          rm /tmp/go.tar.gz
          
          # Create directories
          mkdir -p /opt/test-services/{configs,logs}
          chown -R debian:debian /opt/test-services
          
          # Simple health endpoint
          cat > /opt/test-services/health-check.sh << 'HEALTH_EOF'
          #!/bin/bash
          API_STATUS="down"
          TEST_STATUS="down"
          
          if curl -s http://localhost:8080/health >/dev/null 2>&1; then API_STATUS="up"; fi
          if curl -s http://localhost:5000/health >/dev/null 2>&1; then TEST_STATUS="up"; fi
          
          cat << EOM
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "services": {
              "api_server": "$API_STATUS",
              "test_runner": "$TEST_STATUS"
            }
          }
          EOM
          HEALTH_EOF
          
          chmod +x /opt/test-services/health-check.sh
          
          # Start health endpoint
          python3 -c "
          import http.server, subprocess, json
          class Handler(http.server.BaseHTTPRequestHandler):
              def do_GET(self):
                  if self.path == '/status':
                      result = subprocess.run(['/opt/test-services/health-check.sh'], capture_output=True, text=True)
                      self.send_response(200)
                      self.send_header('Content-type', 'application/json')
                      self.end_headers()
                      self.wfile.write(result.stdout.encode())
                  else:
                      self.send_response(404)
                      self.end_headers()
          
          server = http.server.HTTPServer(('0.0.0.0', 9999), Handler)
          server.serve_forever()
          " &
          
          touch /opt/test-services/setup-complete
          EOF
      
      - name: Create VM Instance
        id: create-vm
        run: |
          VM_NAME="${{ steps.vm-name.outputs.vm_name }}"
          gcloud compute instances create "$VM_NAME" \
            --zone="${{ env.ZONE }}" \
            --machine-type="${{ github.event.inputs.machine_type }}" \
            --network="default" \
            --tags="test-vm-${{ env.DEPLOYMENT_ID }}" \
            --create-disk=auto-delete=yes,boot=yes,device-name="$VM_NAME",image=projects/debian-cloud/global/images/family/debian-12,mode=rw,size=${{ github.event.inputs.disk_size }},type=projects/${{ env.PROJECT_ID }}/zones/${{ env.ZONE }}/diskTypes/pd-standard \
            --labels=deployment-id=${{ env.DEPLOYMENT_ID }},purpose=testing \
            --metadata-from-file startup-script=startup-script.sh \
            --metadata deployment-id=${{ env.DEPLOYMENT_ID }},auto-cleanup-hours=${{ github.event.inputs.auto_cleanup_hours }}
          echo "vm_name=$VM_NAME" >> $GITHUB_OUTPUT
      
      - name: Wait for VM Ready
        run: |
          VM_NAME="${{ steps.create-vm.outputs.vm_name }}"
          for i in {1..30}; do
            STATUS=$(gcloud compute instances describe "$VM_NAME" --zone="${{ env.ZONE }}" --format="get(status)")
            if [[ "$STATUS" == "RUNNING" ]]; then break; fi
            sleep 10
          done
          sleep 60  # Wait for startup script
      
      - name: Get VM IP
        id: get-vm-ip
        run: |
          VM_NAME="${{ steps.create-vm.outputs.vm_name }}"
          VM_IP=$(gcloud compute instances describe "$VM_NAME" --zone="${{ env.ZONE }}" --format="get(networkInterfaces[0].accessConfigs[0].natIP)")
          echo "ip=$VM_IP" >> $GITHUB_OUTPUT
      
      - name: Generate VM Metadata
        run: |
          VM_IP="${{ steps.get-vm-ip.outputs.ip }}"
          VM_NAME="${{ steps.create-vm.outputs.vm_name }}"
          cat > vm-metadata.json << EOF
          {
            "deployment": {
              "id": "${{ env.DEPLOYMENT_ID }}",
              "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
              "region": "${{ env.REGION }}",
              "zone": "${{ env.ZONE }}",
              "auto_cleanup_hours": "${{ github.event.inputs.auto_cleanup_hours }}"
            },
            "vm": {
              "name": "$VM_NAME",
              "external_ip": "$VM_IP",
              "machine_type": "${{ github.event.inputs.machine_type }}",
              "disk_size_gb": "${{ github.event.inputs.disk_size }}",
              "firewall_rule": "allow-test-services-${{ env.DEPLOYMENT_ID }}"
            },
            "services": {
              "deployed": false,
              "status_endpoint": "http://$VM_IP:9999/status"
            }
          }
          EOF
      
      - name: Upload VM Metadata
        uses: actions/upload-artifact@v4
        with:
          name: vm-metadata-${{ env.DEPLOYMENT_ID }}
          path: vm-metadata.json
          retention-days: 30
      
      - name: Display Summary
        run: |
          VM_IP="${{ steps.get-vm-ip.outputs.ip }}"
          VM_NAME="${{ steps.create-vm.outputs.vm_name }}"
          echo "VM Created: $VM_NAME"
          echo "External IP: $VM_IP"
          echo "Region: ${{ env.REGION }}"
          echo "Deployment ID: ${{ env.DEPLOYMENT_ID }}"
          echo "Status Endpoint: http://$VM_IP:9999/status"